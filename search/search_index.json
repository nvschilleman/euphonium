{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Euphonium documentation ~ Euphonium is a highly extensible audio streaming software. It's multiplatform, also supporting low cost MCU's like espressif ESP32 series. Features: ~ Clean and lightweight web-ui Supports multiple plugins: Spotify streaming, Bluetooth (on esp32), Web Radio, Jellyfin Fully modular architecture Easily extendible and portable to new hardware, thanks to the internal Berry-lang powered scripting engine. Required hardware for esp32: ~ Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :) Installing a prebuilt version ~ Feel free to try Euphonium by flashing a newest release . All you need to do is to have esptool.py installed on your system (comes with esp-idf). Unpack the euphonium-{version}.tar.gz and run: flash_all.sh {your serial port} to install it. Building Euphonium yourself ~ See here for development setup instructions .","title":"Euphonium documentation"},{"location":"#euphonium-documentation","text":"Euphonium is a highly extensible audio streaming software. It's multiplatform, also supporting low cost MCU's like espressif ESP32 series.","title":"Euphonium documentation"},{"location":"#features","text":"Clean and lightweight web-ui Supports multiple plugins: Spotify streaming, Bluetooth (on esp32), Web Radio, Jellyfin Fully modular architecture Easily extendible and portable to new hardware, thanks to the internal Berry-lang powered scripting engine.","title":"Features:"},{"location":"#required-hardware-for-esp32","text":"Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :)","title":"Required hardware for esp32:"},{"location":"#installing-a-prebuilt-version","text":"Feel free to try Euphonium by flashing a newest release . All you need to do is to have esptool.py installed on your system (comes with esp-idf). Unpack the euphonium-{version}.tar.gz and run: flash_all.sh {your serial port} to install it.","title":"Installing a prebuilt version"},{"location":"#building-euphonium-yourself","text":"See here for development setup instructions .","title":"Building Euphonium yourself"},{"location":"getting-started/","text":"Getting started with Euphonium ~ The fastest way to give euphonium a go is to use prebuilt version from github releases. Required hardware for esp32: ~ Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :) Installing a prebuilt version ~ Flashing a prebuilt version only consists of a few steps: - Download the newest release . (File with name euphonium-vX.X.X.tar.gz ) - Unpack it - Flash it by running sh flash_all.sh {your serial port} - Configuring the system ~ Reboot the board after flashing. After few seconds \"Euphonium\" network should appear. Connect to it. The password is euphonium . You will now be taken to the WiFi configuration page. In case the page does not open automatically - connect to 192.168.4.1 DAC configuration ~ In the \"DAC configuration\" section you can configure the DAC. Euphonium provides an automated configurator for more popular systems. But you can also manually select, and configure the DAC pins. Enjoy your music ~ This is all that's required to get euphonium up and running.","title":"Getting Started"},{"location":"getting-started/#getting-started-with-euphonium","text":"The fastest way to give euphonium a go is to use prebuilt version from github releases.","title":"Getting started with Euphonium"},{"location":"getting-started/#required-hardware-for-esp32","text":"Any ESP32 chip with at least 4MB of flash and 4MB of PSRAM. Wrover chips are usually a good call :)","title":"Required hardware for esp32:"},{"location":"getting-started/#installing-a-prebuilt-version","text":"Flashing a prebuilt version only consists of a few steps: - Download the newest release . (File with name euphonium-vX.X.X.tar.gz ) - Unpack it - Flash it by running sh flash_all.sh {your serial port} -","title":"Installing a prebuilt version"},{"location":"getting-started/#configuring-the-system","text":"Reboot the board after flashing. After few seconds \"Euphonium\" network should appear. Connect to it. The password is euphonium . You will now be taken to the WiFi configuration page. In case the page does not open automatically - connect to 192.168.4.1","title":"Configuring the system"},{"location":"getting-started/#dac-configuration","text":"In the \"DAC configuration\" section you can configure the DAC. Euphonium provides an automated configurator for more popular systems. But you can also manually select, and configure the DAC pins.","title":"DAC configuration"},{"location":"getting-started/#enjoy-your-music","text":"This is all that's required to get euphonium up and running.","title":"Enjoy your music"},{"location":"hardware/","text":"Hardware ~ Euphonium has been confirmed to work fine with a bunch of hardware. ESP32-Specific Please note that Euphonium officially works on any Linux / MacOS machine. This list is only specific to the ESP32 platform. Officially supported boards ~ All of following boards have a automatic configuration support in he web interface. Ai-Thinker ESP32 Audio-Kit ~ These boards are widely available on different stores for around 10 EUR. Codec differences Older versions of this board come with an AC101 audio codec, while newer ones come with ES8311 . Both versions are supported by Euphonium. Espressif Lyra-T v4.3 ~ Official Espressif's devboard. Powered by ES8311 codec. Officially supported DACs ~ These dacs are supported by euphonium, but require manual pin configuration. ES8311 ~ AC101 ~ TAS5711 ~ Internal DAC of ESP32 ~ MA12070p and MA12040p ~","title":"Hardware"},{"location":"hardware/#hardware","text":"Euphonium has been confirmed to work fine with a bunch of hardware. ESP32-Specific Please note that Euphonium officially works on any Linux / MacOS machine. This list is only specific to the ESP32 platform.","title":"Hardware"},{"location":"hardware/#officially-supported-boards","text":"All of following boards have a automatic configuration support in he web interface.","title":"Officially supported boards"},{"location":"hardware/#ai-thinker-esp32-audio-kit","text":"These boards are widely available on different stores for around 10 EUR. Codec differences Older versions of this board come with an AC101 audio codec, while newer ones come with ES8311 . Both versions are supported by Euphonium.","title":"Ai-Thinker ESP32 Audio-Kit"},{"location":"hardware/#espressif-lyra-t-v43","text":"Official Espressif's devboard. Powered by ES8311 codec.","title":"Espressif Lyra-T v4.3"},{"location":"hardware/#officially-supported-dacs","text":"These dacs are supported by euphonium, but require manual pin configuration.","title":"Officially supported DACs"},{"location":"hardware/#es8311","text":"","title":"ES8311"},{"location":"hardware/#ac101","text":"","title":"AC101"},{"location":"hardware/#tas5711","text":"","title":"TAS5711"},{"location":"hardware/#internal-dac-of-esp32","text":"","title":"Internal DAC of ESP32"},{"location":"hardware/#ma12070p-and-ma12040p","text":"","title":"MA12070p and MA12040p"},{"location":"plugins/","text":"Plugins ~ Euphonium integrates with a number of plugins that extend its functionality. WebRadio ~ This plugin adds support for streaming radios from the internet. It provides a simple web interface for searching through different radio stations, powered by radio-browser.info . Spotify ~ This plugin turns Euphonium into a Spotify-Connect speaker. It allows you to stream audio from their vast audio library, and control it from the spotify apps. Powered by cspot . Warning - this requires Spotify premium Bluetooth ~ (esp32 only) Makes Euphonium act as a Bluetooth A2DP speaker. Simply connect to it, and play your favorite music. Jellyfin ~ Planned plugins ~ AirPlay YouTube / ChromeCast simulator via DIAL Snapcast client Snapcast server","title":"Plugins"},{"location":"plugins/#plugins","text":"Euphonium integrates with a number of plugins that extend its functionality.","title":"Plugins"},{"location":"plugins/#webradio","text":"This plugin adds support for streaming radios from the internet. It provides a simple web interface for searching through different radio stations, powered by radio-browser.info .","title":"WebRadio"},{"location":"plugins/#spotify","text":"This plugin turns Euphonium into a Spotify-Connect speaker. It allows you to stream audio from their vast audio library, and control it from the spotify apps. Powered by cspot . Warning - this requires Spotify premium","title":"Spotify"},{"location":"plugins/#bluetooth","text":"(esp32 only) Makes Euphonium act as a Bluetooth A2DP speaker. Simply connect to it, and play your favorite music.","title":"Bluetooth"},{"location":"plugins/#jellyfin","text":"","title":"Jellyfin"},{"location":"plugins/#planned-plugins","text":"AirPlay YouTube / ChromeCast simulator via DIAL Snapcast client Snapcast server","title":"Planned plugins"},{"location":"status/","text":"Status ~ Euphonium is currently in state of rapid development. Roadmap ~ As of January 2022, most of the core functionality is already implemented. Currently in feature freeze until end of January, in order to prepare the system for wider use. January: Setup a documentation page. Get basic infrastucture working via GitHub. Setup reference API for berry and HTTP API. Feburary: Stabilize Spotify, WebRadio and Bluetooth functionality. Assemble some basic hardware, test out battery efficiency. Try to get more feedback on the platform. March - [x] Design and implement new web interface - [x] Provide more mature hardware APIs - [x] Mobile app as scanner - [ ] Implement snapcast client (in progress) TODO - [ ] YouTube client - [ ] Test vendor APIs","title":"Status"},{"location":"status/#status","text":"Euphonium is currently in state of rapid development.","title":"Status"},{"location":"status/#roadmap","text":"As of January 2022, most of the core functionality is already implemented. Currently in feature freeze until end of January, in order to prepare the system for wider use. January: Setup a documentation page. Get basic infrastucture working via GitHub. Setup reference API for berry and HTTP API. Feburary: Stabilize Spotify, WebRadio and Bluetooth functionality. Assemble some basic hardware, test out battery efficiency. Try to get more feedback on the platform. March - [x] Design and implement new web interface - [x] Provide more mature hardware APIs - [x] Mobile app as scanner - [ ] Implement snapcast client (in progress) TODO - [ ] YouTube client - [ ] Test vendor APIs","title":"Roadmap"},{"location":"http/","text":"Euphonium REST API ~ By it's design, Euphonium is a modular system. The REST API consists of the main set of endpoints available on every system, and then of endpoints defined by given plugins.","title":"Euphonium REST API"},{"location":"http/#euphonium-rest-api","text":"By it's design, Euphonium is a modular system. The REST API consists of the main set of endpoints available on every system, and then of endpoints defined by given plugins.","title":"Euphonium REST API"},{"location":"http/devtools/","text":"DevTools Plugin API ~ Extension of Euphonium REST API. This plugin provides an API that allows for modification of the internal scripts, a functionality required by th web-ide. Events ~ This plugin does not provide custom events. DevTools ~ GET /devtools/file ~ Returns list of all files available in the scripts filesystem. Parameters ~ This endpoint does not take any parameters. Response ~ Returns list of files Response type application/json [ \"app.be\" , \"init.be\" , \"esp32/dac.be\" ] POST /devtools/file/:filePath ~ Updates content of the file under filePath . In case of file not existing, it creates one. Parameters ~ Parameter type Description filePath path Path to the file, including name body body Contents of the file Response ~ Returns list of files Response type application/json [ \"app.be\" , \"init.be\" , \"esp32/dac.be\" ] GET /devtools/logs ~ Returns newest logfile. Parameters ~ This endpoint does not take any parameters. Response ~ Returns logs Response type text/plain . This response is not a json, its just a list of logs split by a newline. I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [cspot] ZeroconfAuthenticator.cpp:26: Got request for info I [persistor] ConfigPersistor.cpp:71: Sending file: index.html I [persistor] ConfigPersistor.cpp:71: Sending file: assets/index.4aec51d4.css I [persistor] ConfigPersistor.cpp:71: Sending file: assets/index.a6e012ba.js I [persistor] ConfigPersistor.cpp:71: Sending file: assets/vendor.0e1590e8.js","title":"Plugin - DevTools"},{"location":"http/devtools/#devtools-plugin-api","text":"Extension of Euphonium REST API. This plugin provides an API that allows for modification of the internal scripts, a functionality required by th web-ide.","title":"DevTools Plugin API"},{"location":"http/devtools/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/devtools/#devtools","text":"","title":"DevTools"},{"location":"http/devtools/#get-devtoolsfile","text":"Returns list of all files available in the scripts filesystem.","title":"GET /devtools/file"},{"location":"http/devtools/#post-devtoolsfilefilepath","text":"Updates content of the file under filePath . In case of file not existing, it creates one.","title":"POST /devtools/file/:filePath"},{"location":"http/devtools/#get-devtoolslogs","text":"Returns newest logfile.","title":"GET /devtools/logs"},{"location":"http/main/","text":"Euphonium REST API ~ Every instance of the player exposes a HTTP API, internally used by the web-ui and the web-ide. This API is accessible under the default port. Warning This API is not stable yet, and may change in the future. In particular, authentication is not implemented at this moment. Events ~ Euphonium's HTTP server exposes a endpoint for receiving live events. The events are sent as JSON objects. This is implemented as a long-lived connection to the /events endpoint. This is used for real time updates in the web ide. Plugins ~ Manages internal plugins. GET /plugins ~ Returns list of currently active plugins. Parameters ~ This endpoint does not have parameters Responses ~ Returns list of plugins Response type application/json [ { \"type\" : \"plugin\" , \"name\" : \"cspot\" , \"displayName\" : \"Spotify (cspot)\" }, { \"type\" : \"plugin\" , \"name\" : \"webradio\" , \"displayName\" : \"WebRadio\" }, { \"type\" : \"app\" , \"name\" : \"webradio\" , \"displayName\" : \"WebRadio\" }, ] GET /plugins/:pluginName ~ Returns configuration schema with current values for given plugin. Parameters ~ Parameter type Description pluginName path string Name of the plugin to retrieve configuration of. Responses ~ Returns plugin configuration Response type application/json . Example of spotify. { \"configSchema\" : { \"audioBitrate\" : { \"value\" : \"160\" , \"tooltip\" : \"Audio bitrate\" , \"type\" : \"stringList\" , \"defaultValue\" : \"160\" , \"listValues\" : [ \"96\" , \"160\" , \"320\" ] }, \"receiverName\" : { \"tooltip\" : \"Speaker's name\" , \"type\" : \"string\" , \"value\" : \"Euphonium (cspot)\" , \"defaultValue\" : \"Euphonium (cspot)\" } }, \"themeColor\" : \"#1DB954\" , \"displayName\" : \"Spotify (cspot)\" } POST /plugins/:pluginName ~ Updates configuration of given plugin schema. This configuration is persisted between reboots. Parameters ~ Parameter type Description pluginName path string Name of the plugin to retrieve configuration of. body body PluginConfig Content described below. Requests ~ Change spotify configuration Response type application/json . { \"audioBitrate\" : \"320\" , \"receiverName\" : \"Living room\\'s speaker\" } Responses ~ Returns plugin configuration Request type application/json . Example of spotify. { \"configSchema\" : { \"audioBitrate\" : { \"value\" : \"320\" , \"tooltip\" : \"Audio bitrate\" , \"type\" : \"stringList\" , \"defaultValue\" : \"160\" , \"listValues\" : [ \"96\" , \"160\" , \"320\" ] }, \"receiverName\" : { \"tooltip\" : \"Speaker's name\" , \"type\" : \"string\" , \"value\" : \"Living room\\'s speaker\" , \"defaultValue\" : \"Euphonium (cspot)\" } }, \"themeColor\" : \"#1DB954\" , \"displayName\" : \"Spotify (cspot)\" } Playback ~ Manages the playback state of the system. GET /playback ~ Returns complete current state of playback, containing current track, current position, current volume and current eq settings. Parameters ~ This endpoint does not have parameters Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 50 , \"eq\" : { \"low\" : 0 , \"mid\" : -0.5 , \"high\" : 0 } } POST /playback/volume ~ Updates playback current volume. Parameters ~ Parameter type Description body body Volume Content described below. Requests ~ Change volume Request type application/json . Volume is an integer betwen 0 and 100. { \"volume\" : 100 , } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 100 , \"eq\" : { \"low\" : 0 , \"mid\" : -0.5 , \"high\" : 0 } } POST /playback/eq ~ Updates playback current equalizer settings. Parameters ~ Parameter type Description body body Eq Content described below. Requests ~ Change equalizer settings Request type application/json . Equalizer settings are an object with keys low , mid and high . One value on the scale corresponds to 3 dB. { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"paused\" , \"volume\" : 100 , \"eq\" : { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } } POST /playback/status ~ Updates playback current playback status. Parameters ~ Parameter type Description body body Playback Content described below. Requests ~ Change playback settings Request type application/json . Status is either 'playing' or 'paused' { \"status\" : \"playing\" } Responses ~ Returns current playback state Response type application/json . Example of spotify. { \"song\" : { \"icon\" : \"https://i.scdn.co/image/kocz.jpg\" , \"songName\" : \"Never Gonna Give You Up\" , \"albumName\" : \"Never Gonna Give You Up\" , \"sourceName\" : \"cspot\" , \"artistName\" : \"Rick Astley\" , }, \"status\" : \"playing\" , \"volume\" : 100 , \"eq\" : { \"low\" : 1.25 , \"mid\" : 0 , \"high\" : 0 } } System ~ Manages the state of the system. GET /system ~ Returns information about current system state. Parameters ~ This endpoint does not have parameters Responses ~ Returns current system state Response type application/json . { \"networkState\" : \"online\" , \"version\" : \"0.0.14\" } POST /system/reboot ~ Returns information about current system state. Parameters ~ Calling this endpoint will reboot the system. Responses ~ Returns current system state Response type application/json . { \"version\" : \"0.0.14\" , \"networkState\" : \"rebooting\" , } WiFi ~ Manages state of the WiFi connection GET /wifi ~ Returns current WiFi state. Parameters ~ This endpoint does not have parameters Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"connected\" , \"ipAddress\" : \"192.168.254.103\" } POST /wifi/connect ~ Connects to WiFi network. Parameters ~ Parameter type Description body body WiFiSettings Content described below. Requests ~ WiFi network parameters Request type application/json . { \"ssid\" : \"RandomNetwork\" , \"password\" : \"Test123\" } Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"connecting\" , } POST /wifi/scan_start ~ Starts WiFi network scan. Parameters ~ This endpoint does not have parameters Responses ~ Returns current WiFi state Response type application/json . Example of connected to AP. { \"state\" : \"scanning\" , }","title":"Core"},{"location":"http/main/#euphonium-rest-api","text":"Every instance of the player exposes a HTTP API, internally used by the web-ui and the web-ide. This API is accessible under the default port. Warning This API is not stable yet, and may change in the future. In particular, authentication is not implemented at this moment.","title":"Euphonium REST API"},{"location":"http/main/#events","text":"Euphonium's HTTP server exposes a endpoint for receiving live events. The events are sent as JSON objects. This is implemented as a long-lived connection to the /events endpoint. This is used for real time updates in the web ide.","title":"Events"},{"location":"http/main/#plugins","text":"Manages internal plugins.","title":"Plugins"},{"location":"http/main/#get-plugins","text":"Returns list of currently active plugins.","title":"GET /plugins"},{"location":"http/main/#get-pluginspluginname","text":"Returns configuration schema with current values for given plugin.","title":"GET /plugins/:pluginName"},{"location":"http/main/#post-pluginspluginname","text":"Updates configuration of given plugin schema. This configuration is persisted between reboots.","title":"POST /plugins/:pluginName"},{"location":"http/main/#playback","text":"Manages the playback state of the system.","title":"Playback"},{"location":"http/main/#get-playback","text":"Returns complete current state of playback, containing current track, current position, current volume and current eq settings.","title":"GET /playback"},{"location":"http/main/#post-playbackvolume","text":"Updates playback current volume.","title":"POST /playback/volume"},{"location":"http/main/#post-playbackeq","text":"Updates playback current equalizer settings.","title":"POST /playback/eq"},{"location":"http/main/#post-playbackstatus","text":"Updates playback current playback status.","title":"POST /playback/status"},{"location":"http/main/#system","text":"Manages the state of the system.","title":"System"},{"location":"http/main/#get-system","text":"Returns information about current system state.","title":"GET /system"},{"location":"http/main/#post-systemreboot","text":"Returns information about current system state.","title":"POST /system/reboot"},{"location":"http/main/#wifi","text":"Manages state of the WiFi connection","title":"WiFi"},{"location":"http/main/#get-wifi","text":"Returns current WiFi state.","title":"GET /wifi"},{"location":"http/main/#post-wificonnect","text":"Connects to WiFi network.","title":"POST /wifi/connect"},{"location":"http/main/#post-wifiscan_start","text":"Starts WiFi network scan.","title":"POST /wifi/scan_start"},{"location":"http/ota/","text":"OTA Plugin API ~ Extension of Euphonium REST API. This plugin provides an API for OTA updates on the esp32 platform. Events ~ This plugin does not provide custom events. OTA ~ POST /ota ~ This endpoint sets the URL and sha256 of the firmware image to be downloaded, and reboots the device into recovery. Parameters ~ Parameter type Description body body OTA Content described below. Requests ~ Set OTA url and it's sha256 Request type application/json . { \"url\" : \"https://github.com/feelfreelinux/euphonium/releases/download/v0.0.14/ota.bin\" , \"sha256\" : \"e25ec6490d7cf480a26b5f18d7a50b8a7db247b18da749f3d938e8581bf92e22\" } Responses ~ Returns update OTA manifest Response type application/json { \"url\" : \"https://github.com/feelfreelinux/euphonium/releases/download/v0.0.14/ota.bin\" , \"sha256\" : \"e25ec6490d7cf480a26b5f18d7a50b8a7db247b18da749f3d938e8581bf92e22\" }","title":"Plugin - OTA"},{"location":"http/ota/#ota-plugin-api","text":"Extension of Euphonium REST API. This plugin provides an API for OTA updates on the esp32 platform.","title":"OTA Plugin API"},{"location":"http/ota/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/ota/#ota","text":"","title":"OTA"},{"location":"http/ota/#post-ota","text":"This endpoint sets the URL and sha256 of the firmware image to be downloaded, and reboots the device into recovery.","title":"POST /ota"},{"location":"http/webradio/","text":"WebRadio Plugin API ~ Extension of Euphonium REST API. This plugin provides playback of different HTTP audio streams. Events ~ This plugin does not provide custom events. WebRadio ~ POST /webradio ~ In case of another audio source playing, this triggers the web radio source and plays radio with given parameters. Parameters ~ Parameter type Description body body WebRadio Content described below. Requests ~ Set radio url to play Request type application/json . { \"coverImage\" : \"http://example.com/radio.jpeg\" , \"url\" : \"http://example.com/radio.mp3\" , \"codec\" : \"MP3\" , \"name\" : \"Example Radio\" , } Responses ~ Returns set radio settings Response type application/json . { \"coverImage\" : \"http://example.com/radio.jpeg\" , \"url\" : \"http://example.com/radio.mp3\" , \"codec\" : \"MP3\" , \"name\" : \"Example Radio\" , }","title":"Plugin - WebRadio"},{"location":"http/webradio/#webradio-plugin-api","text":"Extension of Euphonium REST API. This plugin provides playback of different HTTP audio streams.","title":"WebRadio Plugin API"},{"location":"http/webradio/#events","text":"This plugin does not provide custom events.","title":"Events"},{"location":"http/webradio/#webradio","text":"","title":"WebRadio"},{"location":"http/webradio/#post-webradio","text":"In case of another audio source playing, this triggers the web radio source and plays radio with given parameters.","title":"POST /webradio"},{"location":"plugins/scripting-language/","text":"Scripting language API ~ Euphonium contains a berry-lang scripting language that can be used to tweak the system for your needs. The following page documents the internal API used in all scripts. Feel free to check euphonium/scripts to see how this is used internally. globals ~ Global utilities Commands ~ Command Signature Supported platforms sleep_ms (milliseconds: int) -> void . Pauses execution for given amount of milliseconds. All core ~ Manages euphonium's core functionality, mostly shared utils. Implemented by Core.cpp Commands ~ Command Signature Supported platforms core.start_plugin (pluginName: string, pluginConfig: map) -> void Starts given plugin's audio thread with following configuration. All core.platform () -> string . Returns platform on which euphonium is currently running. Result being either esp32 or desktop All core.version () -> string . Returns current version of the system. Example result: 0.0.14 All FormContext ~ Class used in plugins that handles UI creation and interaction in the web-ui. Implemented by form_ctx.be Class methods ~ All of the following methods are available on the FormContext class instance. Command Signature Supported platforms text_field (key: string, config: FieldConfig) -> void Adds a text field to the configuration. See FieldConfig below for parameters. All select_field (key: string, config: FieldConfig) -> void Adds a option select / picker field to the configuration. See FieldConfig below for parameters. All checkbox_field (key: string, config: FieldConfig) -> void Adds a checkbox to the configuration. See FieldConfig below for parameters. All create_group (key: string, config: [key: string, label: string]) -> void Adds a new config group to the configuration. All Interface FieldConfig ~ Field Signature Field type label string Configuration field's label visible over the control in the interface. All hint string Used as a hint in the text field. text_field default string Field's default value. All values list All of select field's available values. select_field group string Group that a given field belongs to, previously registered with create_group All http ~ Allows for registering endpoints on the internal HTTP server. Implemented by http.be and HTTPModule.cpp Commands ~ Command Signature Supported platforms http.handle (method: string, path: string, response_handler: [(request) -> void]) -> void Register a new HTTP endpoint under given path . Response handler is a method that takes HTTPRequest as a parameter. See examples below for usage. All http.emit_event (type: string, body: map) -> void . Broadcasts a server-side event to all connected devices. body will be serialized into json string. All Object HTTPRequest ~ Command Signature Supported platforms write_json (body: map, status: int) -> void . Writes a response json to given connection. Body is passed as a map of data to be serialized into json. Status is the HTTP status code of the response. All write_text (body: string, status: int) -> void . Writes the response as text/plain . All json_body () -> map Parses given request's body string into json and returns it as map All query_params () -> map Returns map of parsed query parameters of the given request. All url_params () -> map Returns map of parsed url parameters of the given request. All Example ~ HTTP server usage Handle simple GET and return \"Hello, world!\" http . handle ( 'GET' , '/hello_world' , def ( request ) request . write_text ( \"Hello world!\" , 200 ) end ) Handle POST with json body, return a json response http . handle ( 'POST' , '/create_cat' , def ( request ) if request . json_body () == nil http . write_text ( \"No body\" , request [ 'connection' ], 400 ) else # Parse json body var parsed_body = request . json_body () # Create response var response = { 'name' : parsed_body [ 'name' ], 'age' : 3 } request . write_json ( response , 200 ) end end ) playback ~ Manages playback state of the system. Commands ~ Command Signature Supported platforms playback.set_eq (low: int, mid: int, high: int) -> void . If EqualizerProcessor is enabled, this changes the eq's settings. 1 point on the scale means 3 db. Defaults to 0, 0, 0 (no eq). All playback.set_pause (paused: boolean) -> void . Pauses the playback state. This also triggers a pause event. All playback.empty_buffers () -> void . Empties internal audio buffers of the system. Call this during playback changes / stop pause. All playback.soft_volume (volume: int) -> void Changes the system's software volume. Volume is between 0 and 100 . All euphonium ~ Global euphonium instance object. Handles main events, and keeps a state of plugin registry. Commands ~ Command Signature Supported platforms euphonium.register_plugin (plugin: Plugin) -> void Registers a new euphonium plugin. plugin is a instance of plugin to register in the system. All input ~ ESP32 specific Allows registration of callbacks for input events. Useful for adding buttons, encoders and such. Commands ~ Command Signature Supported platforms hooks ~ Hooks allow to run different instructions during certain boot stages. Used for example to pull up an IO during boot. Commands ~ Command Signature Supported platforms hooks.add_handler (bootstage: int, handler: [() -> void]) -> void Register a new hook. Different bootstage values described below. All enum hooks.BOOTSTAGE ~ Command Description Supported platforms hooks.ON_INIT Called earliest during boot, after scripting VM init. All hooks.POST_SYSTEM Called after all core logic has been initialized, before plugins startup. All hooks.POST_PLUGIN Called after all plugins have been initialized All hooks.AP_INIT Called after AP network has been initialized. esp32 hooks.WIFI_INIT Called after WiFi has been initialized. esp32 Example ~ Sample hook that runs after boot Define I2S configuration, output 256 x MCLK clock on GPIO0. hooks . add_handler ( hooks . ON_INIT , def () print ( \"On boot called!\" ) end ) i2s ~ Controls I2S bus. Mainly used for DAC support. Implemented by I2SDriver.cpp Commands ~ Command Signature Supported platforms i2s.install (configuration: I2SConfig) -> void Installs I2S driver. See below for description of I2SConfig structure. esp32 i2s.delete () -> void . Uninstalls the current I2S driver. esp32 i2s.set_expand (src: int, dst: int) -> void . Enables expand from src bits to dst bits in driver write. Useful for 32bit DAC support. esp32 i2s.disable_expand () -> void . Disables bits expand. esp32 Object I2SConfig ~ Field Description sample_rate int Defines sample rate for the incoming data signal. WARNING - Sample rate is only initial, will be further changed in case od dynamic sample rate bits_per_sample int Bits per sample for incoming data. comm_format one of I2S_CHANNEL_FMT_RIGHT_LEFT , I2S_CHANNEL_FMT_ALL_RIGHT , I2S_CHANNEL_FMT_ALL_LEFT or I2S_CHANNEL_FMT_ONLY_RIGHT channel_format one of I2S_COMM_FORMAT_I2S , I2S_COMM_FORMAT_MSB , I2S_COMM_FORMAT_PCM_SHORT or I2S_COMM_FORMAT_PCM_LONG mclk int if defined and larger than 0, outputs given mclk on GPIO0. Example ~ Sample driver configuration Define I2S configuration, output 256 x MCLK clock on GPIO0. var config = I2SConfig () config . sample_rate = 44100 config . bits_per_sample = 16 config . comm_format = I2S_CHANNEL_FMT_RIGHT_LEFT config . channel_format = I2S_COMM_FORMAT_I2S config . mclk = 256 * 44100 i2s . install ( config ) i2c ~ Controls I2C bus on supported platforms. Mainly used in different drivers. Implemented by I2CDriver.cpp Commands ~ Command Signature Supported platforms i2c.install (sda: int, scl: int) -> void Installs I2C driver under given pins. esp32 i2c.detect (addr:int) -> bool . Tries to detect device under given addr. Returns true if device found. esp32 i2c.read_bytes (addr:int, reg:int, size:int) -> int or nil . Read a value of 1..4 bytes from address addr and register reg. Returns nil if no response. esp32 i2c.write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg. esp32 i2c.read (addr:int, reg:int, size:int) -> int or nil . Reads a singular bytes from a given register. esp32 i2c.write (addr:int, reg:int, val:int) -> nil Writes a singular byte to a given register. esp32 i2c.write_raw (addr:int, val:bytes) -> nil Write a raw sequence of bytes to the given device. esp32 i2c.read_raw (addr:int, val:bytes, size: int) -> int or nil Writes the val sequence of bytes on the i2c line, and then reads size bytes. esp32 Example ~ Write few bytes to I2C device Configure I2C on 21 and 23 pins, then perform two writes. i2c . install ( 21 , 23 ) var deviceAddr = 0x10 # Write 0x01 to register 0x00 i2c . write ( deviceAddr , 0x00 , 0x01 ) # Write byte sequence to register 0x01 i2c . write_bytes ( deviceAddr , 0x01 , bytes ( '1a01' )) gpio ~ Controls GPIO pins on supported platforms. Mainly used in different drivers. Implemented by GPIODriver.cpp Commands ~ Command Signature Supported platforms gpio.digital_write (gpio: int, state: int) -> void Sets GPIO to LOW/HIGH. Needs physical pin number esp32 gpio.digital_read (gpio: int) -> int Returns digital state of given physical GPIO. Either gpio.LOW or gpio.HIGH esp32 gpio.pin_mode (gpio: int, mode: int) -> int Changes the GPIO mode. Only use if if you know what you're doing, by default Euphonium handles GPIO mode itself. Mode can have the following values: gpio.INPUT, gpio.OUTPUT, gpio.PULLUP, gpio.INPUT_PULLUP, gpio.PULLDOWN esp32 gpio.analog_read (gpio: int) -> real . Returns the voltage on a given pin in mV. Only used with DAC pins. esp32 gpio.register_button (gpio: int, event_type: gpio.EVENT_TYPE, handler: [() -> void], config: map([high_state: bool])) -> void Registers a new handler called after interaction with a given button on provided gpio . Supports press, double press, and long press. esp32 enum input.EVENT_TYPE ~ Command Description Supported platforms gpio.PRESS Called on single press of a button. esp32 gpio.DOUBLE_PRESS Called on double press of a button. esp32 gpio.LONG_PRESS Called on long press of a button. esp32 Example ~ GPIO Driver usage Sets GPIO 21 as output, writes its state to HIGH. gpio . pin_mode ( 21 , gpio . OUTPUT ) gpio . digital_write ( 21 , gpio . HIGH ) Example ~ Example button that changes volume when pressed Register a button on gpio 5, and call a function from playback when pressed. gpio . register_button ( 5 , input . PRESS , def () print ( \"Volume up called!\" ) playback . set_volume ( playback . volume + 5 ) end , { 'high_state' : true }) led_strip ~ Allows for control of addressable LEDs like the WS28xx and SK6812. Underneath it uses esp32's RMT driver, to drive up to 8 separate strip instances. Implemented by LEDDriver.cpp Class LEDStrip ~ Field Signature Supported platforms init / constructor (type: LED_TYPE, pin: int, len: int, channel: RMT_CHANNEL, brightness: int?) LEDStrip constructor. Allows control of a singular strip, with a driver type , connected under a GPIO pin . channel is the RMT channel to use. If brightness is provided, the entire LED chain will be dimmed accordingly. esp32 show () -> void Called on existing instance. Will update the LED strip with previously assigned color values esp32 set_item (index, item: [r: number, g: number, b: number]) -> void This implements the API for setting color of individual LEDs via a standard color assign. See example below for usage. r , g and b range from 0 to 255. esp32 enum led_strip.LED_TYPE ~ Value Description LED_WS2812 Indicates WS2812 LED type. LED_WS2812B Indicates WS2812B LED type. LED_SK6812 Indicates SK6812 LED type. LED_WS2813 Indicates WS2813 LED type. Example ~ LED Driver usage Registers a new LED strip under pin 21, consisting of 12 WS2812 leds, at lower brightness. Then turns the first LED red, the second one green. volume_strip = LEDStrip ( LED_WS2812 , 21 , 12 , RMT_CHANNEL_0 , 150 ) # change the first LED to red and second one to green. volume_strip [ 0 ] = [ 255 , 0 , 0 ] # red in RGB format volume_strip [ 1 ] = [ 0 , 255 , 0 ] # green in RGB format # display the changes on the strip volume_strip . show () wifi ~ Controls internal state of the platform's WiFi. Used internally by wifi.be . Implemented by WiFiDriver.cpp Commands ~ Command Signature Supported platforms wifi.init_stack () -> void Initializes the WiFi stack esp32 wifi.connect (ssid: string, password: string, fromAP: bool) -> void Attempts WiFi connection. fromAP should be set according to the current WiFi mode. esp32 wifi.start_ap (ssid: string, password: string) -> void Starts an access point with given credentials. esp32 wifi.start_scan () -> boid . Starts scanning of WiFi networks. esp32","title":"Scripting Language"},{"location":"plugins/scripting-language/#scripting-language-api","text":"Euphonium contains a berry-lang scripting language that can be used to tweak the system for your needs. The following page documents the internal API used in all scripts. Feel free to check euphonium/scripts to see how this is used internally.","title":"Scripting language API"},{"location":"plugins/scripting-language/#globals","text":"Global utilities","title":"globals"},{"location":"plugins/scripting-language/#commands","text":"Command Signature Supported platforms sleep_ms (milliseconds: int) -> void . Pauses execution for given amount of milliseconds. All","title":"Commands"},{"location":"plugins/scripting-language/#core","text":"Manages euphonium's core functionality, mostly shared utils. Implemented by Core.cpp","title":"core"},{"location":"plugins/scripting-language/#commands_1","text":"Command Signature Supported platforms core.start_plugin (pluginName: string, pluginConfig: map) -> void Starts given plugin's audio thread with following configuration. All core.platform () -> string . Returns platform on which euphonium is currently running. Result being either esp32 or desktop All core.version () -> string . Returns current version of the system. Example result: 0.0.14 All","title":"Commands"},{"location":"plugins/scripting-language/#formcontext","text":"Class used in plugins that handles UI creation and interaction in the web-ui. Implemented by form_ctx.be","title":"FormContext"},{"location":"plugins/scripting-language/#class-methods","text":"All of the following methods are available on the FormContext class instance. Command Signature Supported platforms text_field (key: string, config: FieldConfig) -> void Adds a text field to the configuration. See FieldConfig below for parameters. All select_field (key: string, config: FieldConfig) -> void Adds a option select / picker field to the configuration. See FieldConfig below for parameters. All checkbox_field (key: string, config: FieldConfig) -> void Adds a checkbox to the configuration. See FieldConfig below for parameters. All create_group (key: string, config: [key: string, label: string]) -> void Adds a new config group to the configuration. All","title":"Class methods"},{"location":"plugins/scripting-language/#interface-fieldconfig","text":"Field Signature Field type label string Configuration field's label visible over the control in the interface. All hint string Used as a hint in the text field. text_field default string Field's default value. All values list All of select field's available values. select_field group string Group that a given field belongs to, previously registered with create_group All","title":"Interface FieldConfig"},{"location":"plugins/scripting-language/#http","text":"Allows for registering endpoints on the internal HTTP server. Implemented by http.be and HTTPModule.cpp","title":"http"},{"location":"plugins/scripting-language/#commands_2","text":"Command Signature Supported platforms http.handle (method: string, path: string, response_handler: [(request) -> void]) -> void Register a new HTTP endpoint under given path . Response handler is a method that takes HTTPRequest as a parameter. See examples below for usage. All http.emit_event (type: string, body: map) -> void . Broadcasts a server-side event to all connected devices. body will be serialized into json string. All","title":"Commands"},{"location":"plugins/scripting-language/#object-httprequest","text":"Command Signature Supported platforms write_json (body: map, status: int) -> void . Writes a response json to given connection. Body is passed as a map of data to be serialized into json. Status is the HTTP status code of the response. All write_text (body: string, status: int) -> void . Writes the response as text/plain . All json_body () -> map Parses given request's body string into json and returns it as map All query_params () -> map Returns map of parsed query parameters of the given request. All url_params () -> map Returns map of parsed url parameters of the given request. All","title":"Object HTTPRequest"},{"location":"plugins/scripting-language/#example","text":"HTTP server usage Handle simple GET and return \"Hello, world!\" http . handle ( 'GET' , '/hello_world' , def ( request ) request . write_text ( \"Hello world!\" , 200 ) end ) Handle POST with json body, return a json response http . handle ( 'POST' , '/create_cat' , def ( request ) if request . json_body () == nil http . write_text ( \"No body\" , request [ 'connection' ], 400 ) else # Parse json body var parsed_body = request . json_body () # Create response var response = { 'name' : parsed_body [ 'name' ], 'age' : 3 } request . write_json ( response , 200 ) end end )","title":"Example"},{"location":"plugins/scripting-language/#playback","text":"Manages playback state of the system.","title":"playback"},{"location":"plugins/scripting-language/#commands_3","text":"Command Signature Supported platforms playback.set_eq (low: int, mid: int, high: int) -> void . If EqualizerProcessor is enabled, this changes the eq's settings. 1 point on the scale means 3 db. Defaults to 0, 0, 0 (no eq). All playback.set_pause (paused: boolean) -> void . Pauses the playback state. This also triggers a pause event. All playback.empty_buffers () -> void . Empties internal audio buffers of the system. Call this during playback changes / stop pause. All playback.soft_volume (volume: int) -> void Changes the system's software volume. Volume is between 0 and 100 . All","title":"Commands"},{"location":"plugins/scripting-language/#euphonium","text":"Global euphonium instance object. Handles main events, and keeps a state of plugin registry.","title":"euphonium"},{"location":"plugins/scripting-language/#commands_4","text":"Command Signature Supported platforms euphonium.register_plugin (plugin: Plugin) -> void Registers a new euphonium plugin. plugin is a instance of plugin to register in the system. All","title":"Commands"},{"location":"plugins/scripting-language/#input","text":"ESP32 specific Allows registration of callbacks for input events. Useful for adding buttons, encoders and such.","title":"input"},{"location":"plugins/scripting-language/#commands_5","text":"Command Signature Supported platforms","title":"Commands"},{"location":"plugins/scripting-language/#hooks","text":"Hooks allow to run different instructions during certain boot stages. Used for example to pull up an IO during boot.","title":"hooks"},{"location":"plugins/scripting-language/#commands_6","text":"Command Signature Supported platforms hooks.add_handler (bootstage: int, handler: [() -> void]) -> void Register a new hook. Different bootstage values described below. All","title":"Commands"},{"location":"plugins/scripting-language/#enum-hooksbootstage","text":"Command Description Supported platforms hooks.ON_INIT Called earliest during boot, after scripting VM init. All hooks.POST_SYSTEM Called after all core logic has been initialized, before plugins startup. All hooks.POST_PLUGIN Called after all plugins have been initialized All hooks.AP_INIT Called after AP network has been initialized. esp32 hooks.WIFI_INIT Called after WiFi has been initialized. esp32","title":"enum hooks.BOOTSTAGE"},{"location":"plugins/scripting-language/#example_1","text":"Sample hook that runs after boot Define I2S configuration, output 256 x MCLK clock on GPIO0. hooks . add_handler ( hooks . ON_INIT , def () print ( \"On boot called!\" ) end )","title":"Example"},{"location":"plugins/scripting-language/#i2s","text":"Controls I2S bus. Mainly used for DAC support. Implemented by I2SDriver.cpp","title":"i2s"},{"location":"plugins/scripting-language/#commands_7","text":"Command Signature Supported platforms i2s.install (configuration: I2SConfig) -> void Installs I2S driver. See below for description of I2SConfig structure. esp32 i2s.delete () -> void . Uninstalls the current I2S driver. esp32 i2s.set_expand (src: int, dst: int) -> void . Enables expand from src bits to dst bits in driver write. Useful for 32bit DAC support. esp32 i2s.disable_expand () -> void . Disables bits expand. esp32","title":"Commands"},{"location":"plugins/scripting-language/#object-i2sconfig","text":"Field Description sample_rate int Defines sample rate for the incoming data signal. WARNING - Sample rate is only initial, will be further changed in case od dynamic sample rate bits_per_sample int Bits per sample for incoming data. comm_format one of I2S_CHANNEL_FMT_RIGHT_LEFT , I2S_CHANNEL_FMT_ALL_RIGHT , I2S_CHANNEL_FMT_ALL_LEFT or I2S_CHANNEL_FMT_ONLY_RIGHT channel_format one of I2S_COMM_FORMAT_I2S , I2S_COMM_FORMAT_MSB , I2S_COMM_FORMAT_PCM_SHORT or I2S_COMM_FORMAT_PCM_LONG mclk int if defined and larger than 0, outputs given mclk on GPIO0.","title":"Object I2SConfig"},{"location":"plugins/scripting-language/#example_2","text":"Sample driver configuration Define I2S configuration, output 256 x MCLK clock on GPIO0. var config = I2SConfig () config . sample_rate = 44100 config . bits_per_sample = 16 config . comm_format = I2S_CHANNEL_FMT_RIGHT_LEFT config . channel_format = I2S_COMM_FORMAT_I2S config . mclk = 256 * 44100 i2s . install ( config )","title":"Example"},{"location":"plugins/scripting-language/#i2c","text":"Controls I2C bus on supported platforms. Mainly used in different drivers. Implemented by I2CDriver.cpp","title":"i2c"},{"location":"plugins/scripting-language/#commands_8","text":"Command Signature Supported platforms i2c.install (sda: int, scl: int) -> void Installs I2C driver under given pins. esp32 i2c.detect (addr:int) -> bool . Tries to detect device under given addr. Returns true if device found. esp32 i2c.read_bytes (addr:int, reg:int, size:int) -> int or nil . Read a value of 1..4 bytes from address addr and register reg. Returns nil if no response. esp32 i2c.write_bytes (addr:int, reg:int, val:bytes) -> nil Writes the val bytes sequence as bytes() to address addr register reg. esp32 i2c.read (addr:int, reg:int, size:int) -> int or nil . Reads a singular bytes from a given register. esp32 i2c.write (addr:int, reg:int, val:int) -> nil Writes a singular byte to a given register. esp32 i2c.write_raw (addr:int, val:bytes) -> nil Write a raw sequence of bytes to the given device. esp32 i2c.read_raw (addr:int, val:bytes, size: int) -> int or nil Writes the val sequence of bytes on the i2c line, and then reads size bytes. esp32","title":"Commands"},{"location":"plugins/scripting-language/#example_3","text":"Write few bytes to I2C device Configure I2C on 21 and 23 pins, then perform two writes. i2c . install ( 21 , 23 ) var deviceAddr = 0x10 # Write 0x01 to register 0x00 i2c . write ( deviceAddr , 0x00 , 0x01 ) # Write byte sequence to register 0x01 i2c . write_bytes ( deviceAddr , 0x01 , bytes ( '1a01' ))","title":"Example"},{"location":"plugins/scripting-language/#gpio","text":"Controls GPIO pins on supported platforms. Mainly used in different drivers. Implemented by GPIODriver.cpp","title":"gpio"},{"location":"plugins/scripting-language/#commands_9","text":"Command Signature Supported platforms gpio.digital_write (gpio: int, state: int) -> void Sets GPIO to LOW/HIGH. Needs physical pin number esp32 gpio.digital_read (gpio: int) -> int Returns digital state of given physical GPIO. Either gpio.LOW or gpio.HIGH esp32 gpio.pin_mode (gpio: int, mode: int) -> int Changes the GPIO mode. Only use if if you know what you're doing, by default Euphonium handles GPIO mode itself. Mode can have the following values: gpio.INPUT, gpio.OUTPUT, gpio.PULLUP, gpio.INPUT_PULLUP, gpio.PULLDOWN esp32 gpio.analog_read (gpio: int) -> real . Returns the voltage on a given pin in mV. Only used with DAC pins. esp32 gpio.register_button (gpio: int, event_type: gpio.EVENT_TYPE, handler: [() -> void], config: map([high_state: bool])) -> void Registers a new handler called after interaction with a given button on provided gpio . Supports press, double press, and long press. esp32","title":"Commands"},{"location":"plugins/scripting-language/#enum-inputevent_type","text":"Command Description Supported platforms gpio.PRESS Called on single press of a button. esp32 gpio.DOUBLE_PRESS Called on double press of a button. esp32 gpio.LONG_PRESS Called on long press of a button. esp32","title":"enum input.EVENT_TYPE"},{"location":"plugins/scripting-language/#example_4","text":"GPIO Driver usage Sets GPIO 21 as output, writes its state to HIGH. gpio . pin_mode ( 21 , gpio . OUTPUT ) gpio . digital_write ( 21 , gpio . HIGH )","title":"Example"},{"location":"plugins/scripting-language/#example_5","text":"Example button that changes volume when pressed Register a button on gpio 5, and call a function from playback when pressed. gpio . register_button ( 5 , input . PRESS , def () print ( \"Volume up called!\" ) playback . set_volume ( playback . volume + 5 ) end , { 'high_state' : true })","title":"Example"},{"location":"plugins/scripting-language/#led_strip","text":"Allows for control of addressable LEDs like the WS28xx and SK6812. Underneath it uses esp32's RMT driver, to drive up to 8 separate strip instances. Implemented by LEDDriver.cpp","title":"led_strip"},{"location":"plugins/scripting-language/#class-ledstrip","text":"Field Signature Supported platforms init / constructor (type: LED_TYPE, pin: int, len: int, channel: RMT_CHANNEL, brightness: int?) LEDStrip constructor. Allows control of a singular strip, with a driver type , connected under a GPIO pin . channel is the RMT channel to use. If brightness is provided, the entire LED chain will be dimmed accordingly. esp32 show () -> void Called on existing instance. Will update the LED strip with previously assigned color values esp32 set_item (index, item: [r: number, g: number, b: number]) -> void This implements the API for setting color of individual LEDs via a standard color assign. See example below for usage. r , g and b range from 0 to 255. esp32","title":"Class LEDStrip"},{"location":"plugins/scripting-language/#enum-led_stripled_type","text":"Value Description LED_WS2812 Indicates WS2812 LED type. LED_WS2812B Indicates WS2812B LED type. LED_SK6812 Indicates SK6812 LED type. LED_WS2813 Indicates WS2813 LED type.","title":"enum led_strip.LED_TYPE"},{"location":"plugins/scripting-language/#example_6","text":"LED Driver usage Registers a new LED strip under pin 21, consisting of 12 WS2812 leds, at lower brightness. Then turns the first LED red, the second one green. volume_strip = LEDStrip ( LED_WS2812 , 21 , 12 , RMT_CHANNEL_0 , 150 ) # change the first LED to red and second one to green. volume_strip [ 0 ] = [ 255 , 0 , 0 ] # red in RGB format volume_strip [ 1 ] = [ 0 , 255 , 0 ] # green in RGB format # display the changes on the strip volume_strip . show ()","title":"Example"},{"location":"plugins/scripting-language/#wifi","text":"Controls internal state of the platform's WiFi. Used internally by wifi.be . Implemented by WiFiDriver.cpp","title":"wifi"},{"location":"plugins/scripting-language/#commands_10","text":"Command Signature Supported platforms wifi.init_stack () -> void Initializes the WiFi stack esp32 wifi.connect (ssid: string, password: string, fromAP: bool) -> void Attempts WiFi connection. fromAP should be set according to the current WiFi mode. esp32 wifi.start_ap (ssid: string, password: string) -> void Starts an access point with given credentials. esp32 wifi.start_scan () -> boid . Starts scanning of WiFi networks. esp32","title":"Commands"},{"location":"technical/adding-new-dac/","text":"","title":"Adding support to new DAC"},{"location":"technical/adding-new-plugin/","text":"","title":"Writing your own plugin"},{"location":"technical/architecture/","text":"Architecture ~ Plugins ~ Scripting language structure ~ The following table describes folder structure of the internal scripting file system. Folder internal ~ Rewritten by OTA Contains the core of the application. This handles the central classes, main http endpoints, and is the main entrypoint. File Description internal/init.be Main entrypoint of the script loader. Do not add your extensions here, please see extensions.be . internal/api.be Implementation of the main Euphonium REST API. internal/bindings.be Shallow binding classes that allow for communication between Berry and C++. internal/euphonium.be Main Euphonium class which handles system initialization, event handling and plugin registration. internal/http.be Sugar syntax wrapper over the native HTTP server. internal/app-version Text file containing current version, needed for OTA. Folder vendor ~ Rewritten by manufacturer OTA Contains vendor-specific code. This allows for customization of euphonium for different manufacturers. Code here is rewritten with every manufacturer OTA. vendor/init.be - Entry point for all vendor-specific code. Rest of the code here is product-specific. Folder configuration ~ Contains saved configuration of the app in form of *.config.json files. Folder esp32 ~ Contains the ESP32 platform support. TODO: Describe structure . Folder extensions ~ Contains all user scripts. These are loaded last, after all other scripts. You can register your custom driver by appending to extensions.be file.","title":"Architecture"},{"location":"technical/architecture/#architecture","text":"","title":"Architecture"},{"location":"technical/architecture/#plugins","text":"","title":"Plugins"},{"location":"technical/architecture/#scripting-language-structure","text":"The following table describes folder structure of the internal scripting file system.","title":"Scripting language structure"},{"location":"technical/architecture/#folder-internal","text":"Rewritten by OTA Contains the core of the application. This handles the central classes, main http endpoints, and is the main entrypoint. File Description internal/init.be Main entrypoint of the script loader. Do not add your extensions here, please see extensions.be . internal/api.be Implementation of the main Euphonium REST API. internal/bindings.be Shallow binding classes that allow for communication between Berry and C++. internal/euphonium.be Main Euphonium class which handles system initialization, event handling and plugin registration. internal/http.be Sugar syntax wrapper over the native HTTP server. internal/app-version Text file containing current version, needed for OTA.","title":"Folder internal"},{"location":"technical/architecture/#folder-vendor","text":"Rewritten by manufacturer OTA Contains vendor-specific code. This allows for customization of euphonium for different manufacturers. Code here is rewritten with every manufacturer OTA. vendor/init.be - Entry point for all vendor-specific code. Rest of the code here is product-specific.","title":"Folder vendor"},{"location":"technical/architecture/#folder-configuration","text":"Contains saved configuration of the app in form of *.config.json files.","title":"Folder configuration"},{"location":"technical/architecture/#folder-esp32","text":"Contains the ESP32 platform support. TODO: Describe structure .","title":"Folder esp32"},{"location":"technical/architecture/#folder-extensions","text":"Contains all user scripts. These are loaded last, after all other scripts. You can register your custom driver by appending to extensions.be file.","title":"Folder extensions"},{"location":"technical/dev-environment/","text":"Setting up development environment ~ The best way to try euphonium is to flash a prebuilt version. However, if you want to build it yourself, or help out with development, you will need a few dependencies to get this project to build. Setup ~ Setting up web UI bundler ~ First, a required step is to setup all of the dependencies required to build the web UI. Dependencies ~ nodejs in version of at least 14 yarn Installation of both is platform specific, but mostly just comes down to installing them through a package manager. Setting up dependencies ~ Depending on the target platform, esp32 or cli targets differ in required dependencies. Both platforms ~ python with pip pip3 install grpcio-tools protobuf Desktop specific dependencies ~ PortAudio library OpenSSL library both can be installed with a package manager. ESP32-Specific dependencies ~ esp-idf in version 4.4-rc1 . Please follow Espressif's guide . Building and installing the project - Desktop ~ For a desktop run, please run the following commands Setup cd targets/cli mkdir build && cd build cmake .. Build make This will output a binary euphoniumcli which can be later executed to run the platform. The web-ui will be available on port 80 . Building and installing the project - ESP32 ~ For ESP32 target, please run following commands (with esp-idf in the PATH) Setup cd targets/esp32 sh build_recovery.sh sh build_app.sh Build For full flash: sh flash_all.sh {serialport} For app-only flash: sh reflash_app.sh {serialport} For spiffs only flash (berry scripts, webui, configuration): sh reflash_spiffs.sh {serialport} Development improvements ~ There are a few tricks to make the development faster Preconfiguration of WIFI and DAC ~ Every flash of the spiffs partition will reset the internal configuration. It's a bit of a pain when dealing with esp32, as you have to deal with reconfiguration of the system through the AP network with every flash. To avoid this, you can preconfigure the WiFi settings (any any other setting!) to be included in the flashed partition. To configure WiFi, create a file inside of euphonium/scripts/configuration folder, named wifi.config.json , containing following data { \"ssid\": \"YOUR NETWORK SSID\", \"password\": \" YOUR NETWORK PASSWORD\" } After rerunning the reflash_spiffs script WiFi is going to be preconfigured :)","title":"Setting up development environment"},{"location":"technical/dev-environment/#setting-up-development-environment","text":"The best way to try euphonium is to flash a prebuilt version. However, if you want to build it yourself, or help out with development, you will need a few dependencies to get this project to build.","title":"Setting up development environment"},{"location":"technical/dev-environment/#setup","text":"","title":"Setup"},{"location":"technical/dev-environment/#setting-up-web-ui-bundler","text":"First, a required step is to setup all of the dependencies required to build the web UI.","title":"Setting up web UI bundler"},{"location":"technical/dev-environment/#setting-up-dependencies","text":"Depending on the target platform, esp32 or cli targets differ in required dependencies.","title":"Setting up dependencies"},{"location":"technical/dev-environment/#building-and-installing-the-project-desktop","text":"For a desktop run, please run the following commands Setup cd targets/cli mkdir build && cd build cmake .. Build make This will output a binary euphoniumcli which can be later executed to run the platform. The web-ui will be available on port 80 .","title":"Building and installing the project - Desktop"},{"location":"technical/dev-environment/#building-and-installing-the-project-esp32","text":"For ESP32 target, please run following commands (with esp-idf in the PATH) Setup cd targets/esp32 sh build_recovery.sh sh build_app.sh Build For full flash: sh flash_all.sh {serialport} For app-only flash: sh reflash_app.sh {serialport} For spiffs only flash (berry scripts, webui, configuration): sh reflash_spiffs.sh {serialport}","title":"Building and installing the project - ESP32"},{"location":"technical/dev-environment/#development-improvements","text":"There are a few tricks to make the development faster","title":"Development improvements"},{"location":"technical/dev-environment/#preconfiguration-of-wifi-and-dac","text":"Every flash of the spiffs partition will reset the internal configuration. It's a bit of a pain when dealing with esp32, as you have to deal with reconfiguration of the system through the AP network with every flash. To avoid this, you can preconfigure the WiFi settings (any any other setting!) to be included in the flashed partition. To configure WiFi, create a file inside of euphonium/scripts/configuration folder, named wifi.config.json , containing following data { \"ssid\": \"YOUR NETWORK SSID\", \"password\": \" YOUR NETWORK PASSWORD\" } After rerunning the reflash_spiffs script WiFi is going to be preconfigured :)","title":"Preconfiguration of WIFI and DAC"},{"location":"technical/tasks/","text":"Tasks - esp32 specific ~ The following table lists all of internal FreeRtos tasks running in Euphonium, along with their core affinity and stack size. Core / system ~ Task name Type Stack size Core affinity Priority PSRAM wifi system - 0 - No bluetooth system - 1 - No euphonium core 8192 0 2 No Core core 4096 0 2 Yes http plugin 6144 0 1 No persistor plugin 4096 1 0 No CSpot - plugin ~ Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Considerations ~ Due to internal use of hardware AES, AudioChunkManager needs to be ran on same core as wifi . Task name Stack size Core affinity Priority PSRAM Always active CSpotPlugin 4096 1 0 Yes Yes MercuryManager 6144 1 1 Yes No AudioChunkManager 4096 0 1 Yes No Player 10240 1 0 Yes No Web Radio - plugin ~ Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Task name Stack size Core affinity Priority PSRAM Always active WebRadioPlugin 6144 1 1 Yes Yes","title":"Tasks - esp32 specific"},{"location":"technical/tasks/#tasks-esp32-specific","text":"The following table lists all of internal FreeRtos tasks running in Euphonium, along with their core affinity and stack size.","title":"Tasks - esp32 specific"},{"location":"technical/tasks/#core-system","text":"Task name Type Stack size Core affinity Priority PSRAM wifi system - 0 - No bluetooth system - 1 - No euphonium core 8192 0 2 No Core core 4096 0 2 Yes http plugin 6144 0 1 No persistor plugin 4096 1 0 No","title":"Core / system"},{"location":"technical/tasks/#cspot-plugin","text":"Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback.","title":"CSpot - plugin"},{"location":"technical/tasks/#considerations","text":"Due to internal use of hardware AES, AudioChunkManager needs to be ran on same core as wifi . Task name Stack size Core affinity Priority PSRAM Always active CSpotPlugin 4096 1 0 Yes Yes MercuryManager 6144 1 1 Yes No AudioChunkManager 4096 0 1 Yes No Player 10240 1 0 Yes No","title":"Considerations"},{"location":"technical/tasks/#web-radio-plugin","text":"Always active tasks run all the time when euphonium is IDLE, remaining only runs during playback. Task name Stack size Core affinity Priority PSRAM Always active WebRadioPlugin 6144 1 1 Yes Yes","title":"Web Radio - plugin"}]}